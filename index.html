
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rutherford Experiment - Enhanced</title>
    
    <!-- Include required libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    
    <style>
        #angleGraph {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 0.5rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #f5f5dc;
        }
        
        #scene-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .slider-container {
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 0.5rem;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .info-list {
            list-style-type: disc;
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }

        .info-list li {
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
            color: #4a5568;
        }
    </style>
</head>
<body class="text-gray-900">
    <!-- Controls Panel -->
    <div class="fixed top-4 right-4 bg-white bg-opacity-90 p-4 rounded-lg shadow-xl z-50 w-72 border border-gray-300">
        <h1 class="text-xl font-bold mb-4 text-purple-600 border-b border-purple-300 pb-2">
            Rutherford's Gold Foil Experiment
        </h1>
        
        <!-- Emission Rate Control -->
        <div class="slider-container">
            <div class="slider-label">
                <span class="text-sm text-gray-700">Emission Rate:</span>
                <span id="rateValue" class="text-green-600 font-mono">30</span>
                <span class="text-sm text-gray-600">particles/sec</span>
            </div>
            <input type="range" 
                   id="emissionRate" 
                   min="1" 
                   max="3000" 
                   value="30" 
                   class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-purple-500">
        </div>

        <!-- Animation Speed Control -->
        <div class="slider-container">
            <div class="slider-label">
                <span class="text-sm text-gray-700">Animation Speed:</span>
                <span id="speedValue" class="text-blue-600 font-mono">1.0</span>
                <span class="text-sm text-gray-600">x</span>
            </div>
            <input type="range" 
                   id="animationSpeed" 
                   min="0.1" 
                   max="2.0" 
                   step="0.1" 
                   value="1.0" 
                   class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
        </div>

        <!-- Kinetic Energy Control -->
        <div class="slider-container">
            <div class="slider-label">
                <span class="text-sm text-gray-700">Kinetic Energy:</span>
                <span id="energyValue" class="text-orange-600 font-mono">5.0</span>
                <span class="text-sm text-gray-600">MeV</span>
            </div>
            <input type="range" 
                   id="kineticEnergy" 
                   min="1.0" 
                   max="10.0" 
                   step="0.1" 
                   value="5.0" 
                   class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-orange-500">
        </div>
        
        <!-- Statistics Display -->
        <div id="statsDisplay" class="bg-gray-100 bg-opacity-80 p-3 rounded-lg mb-4 text-sm border border-gray-300">
            <div class="flex justify-between mb-1">
                <span class="text-gray-700">Total Particles:</span>
                <span id="totalParticles" class="font-mono text-green-600">0</span>
            </div>
            <div class="flex justify-between mb-1">
                <span class="text-gray-700">Large Deflections (>90°):</span>
                <span id="significantDeflections" class="font-mono text-yellow-600">0</span>
            </div>
            <div class="flex justify-between">
                <span class="text-gray-700">Deflection Ratio:</span>
                <span id="deflectionRatio" class="font-mono text-yellow-600">0.00%</span>
            </div>
            <div class="flex justify-between mt-1">
                <span class="text-gray-700">Average Energy:</span>
                <span id="avgEnergy" class="font-mono text-orange-600">5.00 MeV</span>
            </div>
        </div>
        
        <!-- Reset Button -->
        <button id="resetBtn" class="w-full bg-purple-500 hover:bg-purple-600 text-white py-2 px-4 rounded-lg 
                                   transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-md">
            Reset Experiment
        </button>
    </div>

    <!-- Info Panel -->
    <div class="fixed top-4 left-4 bg-white bg-opacity-90 p-4 rounded-lg max-w-xs text-sm z-50 
                border border-gray-300 shadow-lg" style="margin-top: 100px;">
        <strong class="text-purple-600">About This Simulation:</strong>
        <p class="text-gray-700 mt-1">
            This simulation demonstrates Rutherford's gold foil experiment with alpha particles (mass: 4u).(Click on gold foil to have an atomic view)
            <br><br>
            Deflection probabilities:
        </p>
        <ul class="info-list">
            <li>95% - No deflection (0-10°)</li>
            <li>4.5% - Small deflection (10-90°)</li>
            <li>0.5% - Large deflection (>90°)</li>
            <li>0.005% - Backscatter (~180°)</li>
        </ul>
    </div>

    <!-- Graph Container -->
    <div class="fixed bottom-4 left-4 w-96 h-64 z-50 bg-white bg-opacity-90 rounded-lg 
                border border-gray-300 shadow-lg p-2">
        <canvas id="angleGraph"></canvas>
    </div>

    <!-- Three.js Scene Container -->
    <div id="scene-container"></div>

    <script>
        // Simulation Constants
        const SETTINGS = {
            EMISSION_MULTIPLIER: 10,
            GOLD_FOIL_SIZE: 2.5,
            DETECTOR_RADIUS: 5,
            DETECTOR_HEIGHT: 1.7,
            DEFLECTION_EXAGGERATION: 160,
            MAX_PARTICLES: 3000,
            PARTICLE_SIZE: 0.05,
            BATCH_SIZE: 100,
            UPDATE_INTERVAL: 16,
            GRAPH_UPDATE_INTERVAL: 100,
            ALPHA_PARTICLE_MASS: 4,
            ENERGY_TO_VELOCITY_FACTOR: 13.832,
            DEFAULT_KINETIC_ENERGY: 5.0,
            MIN_EMISSION_INTERVAL: 1/120
        };

        // Particle System Class
        class ParticleSystem {
            constructor(scene, maxParticles) {
                this.maxParticles = maxParticles;
                this.particleCount = 0;
                
                const geometry = new THREE.SphereGeometry(SETTINGS.PARTICLE_SIZE, 4, 4);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.9
                });

                this.instancedMesh = new THREE.InstancedMesh(geometry, material, maxParticles);
                this.instancedMesh.count = 0;
                scene.add(this.instancedMesh);

                // Initialize arrays for particle data
                this.positions = new Float32Array(maxParticles * 3);
                this.velocities = new Float32Array(maxParticles * 3);
                this.colors = new Float32Array(maxParticles * 3);
                this.active = new Uint8Array(maxParticles);
                this.deflected = new Uint8Array(maxParticles);
                this.energies = new Float32Array(maxParticles);
                
                this.matrix = new THREE.Matrix4();
            }

            addParticle(position, velocity, energy) {
                if (this.particleCount >= this.maxParticles) return -1;
                
                const index = this.particleCount++;
                const offset = index * 3;
                
                // Set initial position
                this.positions[offset] = position.x;
                this.positions[offset + 1] = position.y;
                this.positions[offset + 2] = position.z;
                
                // Set initial velocity
                this.velocities[offset] = velocity.x;
                this.velocities[offset + 1] = velocity.y;
                this.velocities[offset + 2] = velocity.z;
                
                this.energies[index] = energy;
                this.active[index] = 1;
                this.deflected[index] = 0;
                
                // Update instance matrix
                this.matrix.setPosition(position.x, position.y, position.z);
                this.instancedMesh.setMatrixAt(index, this.matrix);
                
                this.instancedMesh.count = this.particleCount;
                this.instancedMesh.instanceMatrix.needsUpdate = true;
                
                return index;
            }

            updateParticles(deltaTime) {
                for (let i = 0; i < this.particleCount; i++) {
                    if (!this.active[i]) continue;
                    
                    const offset = i * 3;
                    
                    // Update position
                    this.positions[offset] += this.velocities[offset] * deltaTime;
                    this.positions[offset + 1] += this.velocities[offset + 1] * deltaTime;
                    this.positions[offset + 2] += this.velocities[offset + 2] * deltaTime;
                    
                    // Check for foil collision
                    if (!this.deflected[i] && 
                        Math.abs(this.positions[offset]) < 0.2 &&
                        Math.abs(this.positions[offset + 1]) < SETTINGS.GOLD_FOIL_SIZE/2 &&
                        Math.abs(this.positions[offset + 2]) < SETTINGS.GOLD_FOIL_SIZE/2) {
                        this.calculateDeflection(i);
                    }
                    
                    // Update matrix
                    this.matrix.setPosition(
                        this.positions[offset],
                        this.positions[offset + 1],
                        this.positions[offset + 2]
                    );
                    this.instancedMesh.setMatrixAt(i, this.matrix);
                    
                    // Check bounds
                    if (this.isOutOfBounds(offset)) {
                        this.active[i] = 0;
                        this.instancedMesh.setMatrixAt(i, new THREE.Matrix4());
                    }
                }
                
                this.instancedMesh.instanceMatrix.needsUpdate = true;
                
                if (this.particleCount > SETTINGS.MAX_PARTICLES * 0.9) {
                    this.compactParticles();
                }
            }

            isOutOfBounds(offset) {
                return (
                    Math.abs(this.positions[offset + 1]) > SETTINGS.DETECTOR_HEIGHT/2 + 10 ||
                    Math.abs(this.positions[offset]) > SETTINGS.DETECTOR_RADIUS + 15 ||
                    Math.abs(this.positions[offset + 2]) > SETTINGS.DETECTOR_RADIUS + 15
                );
            }

            compactParticles() {
                let writeIndex = 0;
                for (let readIndex = 0; readIndex < this.particleCount; readIndex++) {
                    if (this.active[readIndex]) {
                        if (writeIndex !== readIndex) {
                            // Copy particle data
                            const readOffset = readIndex * 3;
                            const writeOffset = writeIndex * 3;
                            
                            this.positions.copyWithin(writeOffset, readOffset, readOffset + 3);
                            this.velocities.copyWithin(writeOffset, readOffset, readOffset + 3);
                            this.active[writeIndex] = this.active[readIndex];
                            this.deflected[writeIndex] = this.deflected[readIndex];
                            this.energies[writeIndex] = this.energies[readIndex];
                            
                            // Update matrix
                            this.matrix.setPosition(
                                this.positions[writeOffset],
                                this.positions[writeOffset + 1],
                                this.positions[writeOffset + 2]
                            );
                            this.instancedMesh.setMatrixAt(writeIndex, this.matrix);
                        }
                        writeIndex++;
                    }
                }
                
                this.particleCount = writeIndex;
                this.instancedMesh.count = writeIndex;
                this.instancedMesh.instanceMatrix.needsUpdate = true;
            }

            calculateDeflection(index) {
                const offset = index * 3;
                const energy = this.energies[index];
                
                const currentSpeed = Math.sqrt(
                    this.velocities[offset] * this.velocities[offset] +
                    this.velocities[offset + 1] * this.velocities[offset + 1] +
                    this.velocities[offset + 2] * this.velocities[offset + 2]
                );
                
                const energyFactor = Math.max(0.2, 1 / (energy / SETTINGS.DEFAULT_KINETIC_ENERGY));
                
                // Probability-based deflection
                const rand = Math.random();
                let angle;
                
                if (rand < 0.95) {
                    // 95% chance of minimal deflection (0-10 degrees)
                    angle = Math.random() * 10;
                } else if (rand < 0.995) {
                    // 4.5% chance of small to medium deflection (10-90 degrees)
                    angle = 10 + Math.random() * 80;
                } else if (rand < 0.9995) {
                    // 0.5% chance of large deflection (90-170 degrees)
                    angle = 90 + Math.random() * 80;
                } else {
                    // 0.005% chance of backscatter (170-180 degrees)
                    angle = 170 + Math.random() * 10;
                }
                
                // Apply energy factor and deflection
                angle *= energyFactor;
                angle = Math.min(angle, 180);
                
                const angleRad = angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                
                const phi = Math.random() * Math.PI * 2;
                this.velocities[offset] = currentSpeed * cos;
                this.velocities[offset + 1] = currentSpeed * sin * Math.cos(phi);
                this.velocities[offset + 2] = currentSpeed * sin * Math.sin(phi);
                
                this.deflected[index] = 1;
                
                if (angle > 90) {
                    SimulationStats.significantDeflections++;
                }
                SimulationStats.recordDeflection(angle, energy);
                
                // Update particle color based on deflection
                const color = new THREE.Color();
                if (angle > 90) {
                    color.setHex(0xff0000);
                } else if (angle > 45) {
                    color.setHex(0xff9900);
                } else {
                    color.setHex(0x00ff00);
                }
                
                this.instancedMesh.setColorAt(index, color);
                this.instancedMesh.instanceColor.needsUpdate = true;
            }

            reset() {
                this.particleCount = 0;
                this.instancedMesh.count = 0;
                this.active.fill(0);
                this.deflected.fill(0);
                this.energies.fill(0);
                this.instancedMesh.instanceMatrix.needsUpdate = true;
            }
        }

        // Statistics Management
        const SimulationStats = {
            totalParticles: 0,
            significantDeflections: 0,
            angleData: new Array(181).fill(0),
            totalEnergy: 0,
            
            reset() {
                this.totalParticles = 0;
                this.significantDeflections = 0;
                this.angleData.fill(0);
                this.totalEnergy = 0;
                this.updateDisplay();
            },
            
            recordDeflection(angle, energy) {
                this.totalParticles++;
                this.totalEnergy += energy;
                const angleIndex = Math.min(Math.round(angle), 180);
                this.angleData[angleIndex]++;
                
                if (this.totalParticles % 10 === 0) {
                    this.updateDisplay();
                }
            },
            
            updateDisplay() {
                document.getElementById('totalParticles').textContent = 
                    this.totalParticles.toLocaleString();
                document.getElementById('significantDeflections').textContent = 
                    this.significantDeflections.toLocaleString();
                
                const ratio = this.totalParticles > 0 ?
                    (this.significantDeflections / this.totalParticles * 100).toFixed(2) : "0.00";
                document.getElementById('deflectionRatio').textContent = ratio + '%';
                
                const avgEnergy = this.totalParticles > 0 ?
                    (this.totalEnergy / this.totalParticles).toFixed(2) : "0.00";
                document.getElementById('avgEnergy').textContent = avgEnergy + ' MeV';
            }
        };

        // Main Simulation Class
        class RutherfordSimulation {
            constructor() {
                this.setupScene();
                this.setupLights();
                this.setupExperimentComponents();
                this.setupParticleSystem();
                this.setupControls();
                this.setupGraph();
                
                this.lastTime = 0;
                this.emissionRate = 30;
                this.animationSpeed = 1.0;
                this.kineticEnergy = SETTINGS.DEFAULT_KINETIC_ENERGY;
                this.lastEmissionTime = 0;
                this.emissionAccumulator = 0;
                
                this.animate();
            }

            // Helper method for creating floating labels
            createLabel(text, color = 0x000000) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;

                // Background with rounded corners
                context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                context.beginPath();
                context.roundRect(0, 0, canvas.width, canvas.height, 10);
                context.fill();

                // Text
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.fillText(text, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 0.5, 1);

                return sprite;
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf5f5dc);
                
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(-5, 3, 8);
                
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                document.getElementById('scene-container')
                    .appendChild(this.renderer.domElement);
                    
                this.controls = new THREE.OrbitControls(
                    this.camera,
                    this.renderer.domElement
                );
                this.controls.enableDamping = true;
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupLights() {
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
                this.scene.add(hemiLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(5, 10, 7.5);
                this.scene.add(dirLight);
            }
            
            setupExperimentComponents() {
                // Gold foil
                const foilGeometry = new THREE.PlaneGeometry(
                    SETTINGS.GOLD_FOIL_SIZE,
                    SETTINGS.GOLD_FOIL_SIZE
                );
                const foilMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8B7500,
                    metalness: 0.9,
                    roughness: 0.2,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                this.goldFoil = new THREE.Mesh(foilGeometry, foilMaterial);
                this.goldFoil.rotation.y = Math.PI / 2;
                this.scene.add(this.goldFoil);

                // Add Gold Foil label
                const foilLabel = this.createLabel('Gold Foil', 0x8B7500);
                foilLabel.position.set(0, SETTINGS.GOLD_FOIL_SIZE/2 + 1, 0);
                this.scene.add(foilLabel);

                // Add click event for gold foil
                this.goldFoil.userData = { isClickable: true };
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                window.addEventListener('click', (event) => this.onGoldFoilClick(event));
                window.addEventListener('touchstart', (event) => this.onGoldFoilTouch(event));
                
                // Detector
                const detectorGeometry = new THREE.CylinderGeometry(
                    SETTINGS.DETECTOR_RADIUS,
                    SETTINGS.DETECTOR_RADIUS,
                    SETTINGS.DETECTOR_HEIGHT,
                    32,
                    1,
                    true,
                    0,
                    (5/6) * Math.PI * 2
                );
                const detectorMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00688B,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                this.detector = new THREE.Mesh(detectorGeometry, detectorMaterial);
                this.detector.rotation.y = 5 * Math.PI / 3;
                this.scene.add(this.detector);

                // Add Detector label
                const detectorLabel = this.createLabel('Detector Screen', 0x00688B);
                detectorLabel.position.set(SETTINGS.DETECTOR_RADIUS - 1, SETTINGS.DETECTOR_HEIGHT/2 + 1, 0);
                this.scene.add(detectorLabel);
                
                // Emitter
                const emitterGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const emitterMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                this.emitter = new THREE.Mesh(emitterGeometry, emitterMaterial);
                this.emitter.position.set(-10, 0, 0);
                this.scene.add(this.emitter);

                // Add Emitter label
                const emitterLabel = this.createLabel('Particle Emitter', 0xff0000);
                emitterLabel.position.set(-10, 1.5, 0);
                this.scene.add(emitterLabel);
            }

            onGoldFoilClick(event) {
                this.handleGoldFoilInteraction(event.clientX, event.clientY);
            }

            onGoldFoilTouch(event) {
                const touch = event.touches[0];
                this.handleGoldFoilInteraction(touch.clientX, touch.clientY);
            }

            handleGoldFoilInteraction(clientX, clientY) {
                // Calculate touch/mouse position in normalized device coordinates
                this.mouse.x = (clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(clientY / window.innerHeight) * 2 + 1;

                // Update the raycaster
                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Check for intersections
                const intersects = this.raycaster.intersectObject(this.goldFoil);
                if (intersects.length > 0 && this.goldFoil.userData.isClickable) {
                    // Redirect to the specified webpage
                    window.location.href = "https://ishaan123mehta.github.io/rutherford-gold-foil-simulation/"; // Replace with your desired URL
                }
            }
            
            setupParticleSystem() {
                this.particleSystem = new ParticleSystem(
                    this.scene,
                    SETTINGS.MAX_PARTICLES
                );
            }
            
            setupControls() {
                // Emission rate control
                const rateSlider = document.getElementById('emissionRate');
                const rateValue = document.getElementById('rateValue');
                rateSlider.addEventListener('input', (e) => {
                    this.emissionRate = parseInt(e.target.value);
                    rateValue.textContent = this.emissionRate;
                });
                
                // Animation speed control
                const speedSlider = document.getElementById('animationSpeed');
                const speedValue = document.getElementById('speedValue');
                speedSlider.addEventListener('input', (e) => {
                    this.animationSpeed = parseFloat(e.target.value);
                    speedValue.textContent = this.animationSpeed.toFixed(1);
                });
                
                // Kinetic energy control
                const energySlider = document.getElementById('kineticEnergy');
                const energyValue = document.getElementById('energyValue');
                energySlider.addEventListener('input', (e) => {
                    this.kineticEnergy = parseFloat(e.target.value);
                    energyValue.textContent = this.kineticEnergy.toFixed(1);
                });
                
                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.particleSystem.reset();
                    SimulationStats.reset();
                });
            }
            
            setupGraph() {
                const ctx = document.getElementById('angleGraph').getContext('2d');
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: Array.from({length: 37}, (_, i) => i * 5 + '°'),
                        datasets: [{
                            label: 'Particle Deflection Distribution',
                            data: Array(37).fill(0),
                            fill: true,
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Particles'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Deflection Angle'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            }
                        }
                    }
                });
            }
            
            calculateParticleVelocity(kineticEnergy) {
                return Math.sqrt((2 * kineticEnergy) / SETTINGS.ALPHA_PARTICLE_MASS) 
                       * SETTINGS.ENERGY_TO_VELOCITY_FACTOR;
            }
            
            emitParticles(deltaTime) {
                this.emissionAccumulator += deltaTime;
                
                const particlesPerSecond = this.emissionRate;
                const particlesToEmit = Math.floor(particlesPerSecond * this.emissionAccumulator);
                
                if (particlesToEmit > 0) {
                    this.emissionAccumulator -= particlesToEmit / particlesPerSecond;
                    
                    const baseVelocity = this.calculateParticleVelocity(this.kineticEnergy);
                    
                    for (let i = 0; i < particlesToEmit; i++) {
                        const position = new THREE.Vector3(
                            this.emitter.position.x + (Math.random() - 0.5) * 0.1,
                            this.emitter.position.y + (Math.random() - 0.5) * 0.1,
                            this.emitter.position.z + (Math.random() - 0.5) * 0.1
                        );
                        
                        const velocityVariation = 0.1;
                        const velocity = new THREE.Vector3(
                            baseVelocity * (1 + (Math.random() - 0.5) * velocityVariation),
                            baseVelocity * (Math.random() - 0.5) * 0.1,
                            baseVelocity * (Math.random() - 0.5) * 0.1
                        );
                        
                        this.particleSystem.addParticle(position, velocity, this.kineticEnergy);
                    }
                }
            }
            
            updateGraph() {
                const sampledData = [];
                for (let i = 0; i <= 180; i += 5) {
                    let sum = 0;
                    let count = 0;
                    for (let j = Math.max(0, i - 2); j <= Math.min(180, i + 2); j++) {
                                                sum += SimulationStats.angleData[j];
                        count++;
                    }
                    sampledData.push(sum / count);
                }
                
                this.chart.data.datasets[0].data = sampledData;
                this.chart.update('none');
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate(time = 0) {
                requestAnimationFrame((t) => this.animate(t));
                
                const deltaTime = Math.min((time - this.lastTime) / 1000, 0.1) * this.animationSpeed;
                this.lastTime = time;
                
                this.controls.update();
                this.emitParticles(deltaTime);
                this.particleSystem.updateParticles(deltaTime);
                
                if (time % SETTINGS.GRAPH_UPDATE_INTERVAL < 16) {
                    this.updateGraph();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start the simulation when the page loads
        window.addEventListener('load', () => {
            new RutherfordSimulation();
        });
    </script>
</body>
</html>
